import wt, { AxiosError as bt } from "axios";
import * as re from "fs";
import kt from "form-data";
class M {
  content;
  username;
  avatar_url;
  tts;
  embeds = [];
  thread_name;
  flags;
  editTarget;
  /**
   * Creates a new Message instance.
   * @param options Optional initial properties for the message.
   * @param options.content The main text content of the message.
   * @param options.username Overrides the default username of the webhook for this message.
   * @param options.avatar_url Overrides the default avatar of the webhook for this message.
   * @param options.tts If true, the message will be read aloud using text-to-speech.
   * @param options.embeds An array of Embed objects to include in the message.
   * @param options.thread_name If the webhook is in a forum channel, this will create a new thread with this name.
   * @param options.flags Advanced message flags.
   * @param options.editTarget The message link or ID to edit an existing message.
   */
  constructor(t) {
    t && (this.content = t.content, this.username = t.username, this.avatar_url = t.avatar_url, this.tts = t.tts, t.embeds && (this.embeds = t.embeds), this.thread_name = t.thread_name, this.flags = t.flags, this.editTarget = t.editTarget);
  }
  /**
   * Sets the main text content of the message.
   * @param content The text content (max 2000 characters). Markdown is supported.
   * @returns The current Message instance.
   */
  setContent(t) {
    return this.content = t, this;
  }
  /**
   * Overrides the default username of the webhook for this specific message.
   * @param username The username to display.
   * @returns The current Message instance.
   */
  setUsername(t) {
    return this.username = t, this;
  }
  /**
   * Overrides the default avatar of the webhook for this specific message.
   * @param url The URL for the avatar image. Must be a valid image URL.
   * @returns The current Message instance.
   */
  setAvatarURL(t) {
    return this.avatar_url = t, this;
  }
  /**
   * Sets whether the message should be read aloud using text-to-speech.
   * @param tts If true, the message will be read aloud.
   * @returns The current Message instance.
   */
  setTTS(t) {
    return this.tts = t, this;
  }
  /**
   * Adds a single embed to the message.
   * @param embed The Embed object to add.
   * @returns The current Message instance.
   */
  addEmbed(t) {
    return this.embeds.push(t), this;
  }
  /**
   * Adds multiple embeds to the message.
   * @param embeds An array of Embed objects to add.
   * @returns The current Message instance.
   */
  addEmbeds(t) {
    return this.embeds.push(...t), this;
  }
  /**
   * Sets the name of the thread to create if the webhook is in a forum channel.
   * @param name The name of the new thread.
   * @returns The current Message instance.
   */
  setThreadName(t) {
    return this.thread_name = t, this;
  }
  /**
   * Sets advanced message flags.
   * @param flags The bitwise flags for the message.
   * @returns The current Message instance.
   */
  setFlags(t) {
    return this.flags = t, this;
  }
  /**
   * Sets the target message to edit.
   * @param messageLink The full message link or message ID of the message to edit.
   * @returns The current Message instance.
   */
  setEditTarget(t) {
    return this.editTarget = t, this;
  }
  /**
   * Returns the JSON payload for the message.
   * @returns A plain object representing the message's payload.
   */
  getPayload() {
    const t = {};
    return this.content && (t.content = this.content), this.username && (t.username = this.username), this.avatar_url && (t.avatar_url = this.avatar_url), this.tts && (t.tts = this.tts), this.embeds.length > 0 && (t.embeds = this.embeds.map((n) => n.toJSON())), this.thread_name && (t.thread_name = this.thread_name), this.flags && (t.flags = this.flags), t;
  }
}
class zt {
  text;
  icon_url;
  /**
   * Creates a new Footer instance for an embed.
   * @param text The text to display in the footer (max 2048 characters).
   * @param icon_url Optional URL for a small icon next to the text.
   */
  constructor(t, n) {
    this.text = t, this.icon_url = n;
  }
  /**
   * Returns the JSON representation of the footer.
   * @returns A plain object representing the footer's payload.
   */
  toJSON() {
    return {
      text: this.text,
      icon_url: this.icon_url
    };
  }
}
class $t {
  url;
  /**
   * Creates a new Image instance for an embed.
   * @param url The URL for the image.
   */
  constructor(t) {
    this.url = t;
  }
  /**
   * Returns the JSON representation of the image.
   * @returns A plain object representing the image's payload.
   */
  toJSON() {
    return {
      url: this.url
    };
  }
}
class Zt {
  url;
  /**
   * Creates a new Thumbnail instance for an embed.
   * @param url The URL for the thumbnail image.
   */
  constructor(t) {
    this.url = t;
  }
  /**
   * Returns the JSON representation of the thumbnail.
   * @returns A plain object representing the thumbnail's payload.
   */
  toJSON() {
    return {
      url: this.url
    };
  }
}
class W {
  title;
  description;
  url;
  color;
  timestamp;
  author;
  footer;
  image;
  thumbnail;
  fields = [];
  /**
   * Sets the title of the embed.
   * @param title The title of the embed.
   * @returns The current Embed instance.
   */
  setTitle(t) {
    return this.title = t, this;
  }
  /**
   * Sets the description of the embed.
   * @param description The description of the embed.
   * @returns The current Embed instance.
   */
  setDescription(t) {
    return this.description = t, this;
  }
  /**
   * Sets the URL that the title will link to.
   * @param url The URL for the title.
   * @returns The current Embed instance.
   */
  setURL(t) {
    return this.url = t, this;
  }
  /**
   * Sets the color of the embed.
   * @param color The color of the embed as a hexadecimal number (e.g., 0x0099ff).
   * @returns The current Embed instance.
   */
  setColor(t) {
    return this.color = t, this;
  }
  /**
   * Sets the timestamp of the embed.
   * @param timestamp An optional Date object. If not provided, the current date and time will be used.
   * @returns The current Embed instance.
   */
  setTimestamp(t = /* @__PURE__ */ new Date()) {
    return this.timestamp = t.toISOString(), this;
  }
  /**
   * Sets the author of the embed.
   * @param author An object containing the author's name, and optionally a URL and icon URL.
   * @param author.name The name of the author.
   * @param author.url Optional URL for the author's name.
   * @param author.icon_url Optional URL for the author's icon.
   * @returns The current Embed instance.
   */
  setAuthor(t) {
    return this.author = t, this;
  }
  /**
   * Sets the footer of the embed.
   * @param footer An object containing the footer text and optionally an icon URL.
   * @param footer.text The text for the footer.
   * @param footer.icon_url Optional URL for the footer's icon.
   * @returns The current Embed instance.
   */
  setFooter(t) {
    return this.footer = new zt(t.text, t.icon_url), this;
  }
  /**
   * Sets the main image of the embed.
   * @param url The URL of the image.
   * @returns The current Embed instance.
   */
  setImage(t) {
    return this.image = new $t(t), this;
  }
  /**
   * Sets the thumbnail image of the embed.
   * @param url The URL of the thumbnail image.
   * @returns The current Embed instance.
   */
  setThumbnail(t) {
    return this.thumbnail = new Zt(t), this;
  }
  /**
   * Adds a single field to the embed.
   * @param field The Field object to add.
   * @returns The current Embed instance.
   */
  addField(t) {
    return this.fields.push(t), this;
  }
  /**
   * Adds multiple fields to the embed.
   * @param fields An array of Field objects to add.
   * @returns The current Embed instance.
   */
  addFields(t) {
    return this.fields.push(...t), this;
  }
  /**
   * Returns the JSON representation of the embed.
   * @returns A plain object representing the embed's payload.
   */
  toJSON() {
    return {
      title: this.title,
      description: this.description,
      url: this.url,
      color: this.color,
      timestamp: this.timestamp,
      author: this.author,
      footer: this.footer ? this.footer.toJSON() : void 0,
      image: this.image ? this.image.toJSON() : void 0,
      thumbnail: this.thumbnail ? this.thumbnail.toJSON() : void 0,
      fields: this.fields.map((t) => t.toJSON())
    };
  }
}
function a(e, t, n) {
  function r(u, l) {
    var h;
    Object.defineProperty(u, "_zod", {
      value: u._zod ?? {},
      enumerable: !1
    }), (h = u._zod).traits ?? (h.traits = /* @__PURE__ */ new Set()), u._zod.traits.add(e), t(u, l);
    for (const z in i.prototype)
      z in u || Object.defineProperty(u, z, { value: i.prototype[z].bind(u) });
    u._zod.constr = i, u._zod.def = l;
  }
  const o = n?.Parent ?? Object;
  class s extends o {
  }
  Object.defineProperty(s, "name", { value: e });
  function i(u) {
    var l;
    const h = n?.Parent ? new s() : this;
    r(h, u), (l = h._zod).deferred ?? (l.deferred = []);
    for (const z of h._zod.deferred)
      z();
    return h;
  }
  return Object.defineProperty(i, "init", { value: r }), Object.defineProperty(i, Symbol.hasInstance, {
    value: (u) => n?.Parent && u instanceof n.Parent ? !0 : u?._zod?.traits?.has(e)
  }), Object.defineProperty(i, "name", { value: e }), i;
}
class C extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
const We = {};
function T(e) {
  return We;
}
function yt(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, o]) => t.indexOf(+r) === -1).map(([r, o]) => o);
}
function ie(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Be(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function le(e) {
  return e == null;
}
function he(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function Et(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = t.toString();
  let o = (r.split(".")[1] || "").length;
  if (o === 0 && /\d?e-\d?/.test(r)) {
    const l = r.match(/\d?e-(\d?)/);
    l?.[1] && (o = Number.parseInt(l[1]));
  }
  const s = n > o ? n : o, i = Number.parseInt(e.toFixed(s).replace(".", "")), u = Number.parseInt(t.toFixed(s).replace(".", ""));
  return i % u / 10 ** s;
}
const _e = Symbol("evaluating");
function d(e, t, n) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== _e)
        return r === void 0 && (r = _e, r = n()), r;
    },
    set(o) {
      Object.defineProperty(e, t, {
        value: o
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function It(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function P(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function U(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function ve(e) {
  return JSON.stringify(e);
}
const Ve = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function ue(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Ot = Be(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function q(e) {
  if (ue(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(ue(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function Je(e) {
  return q(e) ? { ...e } : e;
}
const St = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function X(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function A(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function c(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Rt(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Nt = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function Tt(e, t) {
  const n = e._zod.def, r = U(e._zod.def, {
    get shape() {
      const o = {};
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && (o[s] = n.shape[s]);
      }
      return P(this, "shape", o), o;
    },
    checks: []
  });
  return A(e, r);
}
function xt(e, t) {
  const n = e._zod.def, r = U(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape };
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && delete o[s];
      }
      return P(this, "shape", o), o;
    },
    checks: []
  });
  return A(e, r);
}
function Pt(e, t) {
  if (!q(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = U(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return P(this, "shape", r), r;
    },
    checks: []
  });
  return A(e, n);
}
function At(e, t) {
  const n = U(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return P(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return A(e, n);
}
function Ut(e, t, n) {
  const r = U(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, s = { ...o };
      if (n)
        for (const i in n) {
          if (!(i in o))
            throw new Error(`Unrecognized key: "${i}"`);
          n[i] && (s[i] = e ? new e({
            type: "optional",
            innerType: o[i]
          }) : o[i]);
        }
      else
        for (const i in o)
          s[i] = e ? new e({
            type: "optional",
            innerType: o[i]
          }) : o[i];
      return P(this, "shape", s), s;
    },
    checks: []
  });
  return A(t, r);
}
function Dt(e, t, n) {
  const r = U(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, s = { ...o };
      if (n)
        for (const i in n) {
          if (!(i in s))
            throw new Error(`Unrecognized key: "${i}"`);
          n[i] && (s[i] = new e({
            type: "nonoptional",
            innerType: o[i]
          }));
        }
      else
        for (const i in o)
          s[i] = new e({
            type: "nonoptional",
            innerType: o[i]
          });
      return P(this, "shape", s), s;
    },
    checks: []
  });
  return A(t, r);
}
function D(e, t = 0) {
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Ke(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function B(e) {
  return typeof e == "string" ? e : e?.message;
}
function x(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const o = B(e.inst?._zod.def?.error?.(e)) ?? B(t?.error?.(e)) ?? B(n.customError?.(e)) ?? B(n.localeError?.(e)) ?? "Invalid input";
    r.message = o;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function pe(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function j(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const Ge = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, ie, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, qe = a("$ZodError", Ge), He = a("$ZodError", Ge, { Parent: Error });
function Ct(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const o of e.issues)
    o.path.length > 0 ? (n[o.path[0]] = n[o.path[0]] || [], n[o.path[0]].push(t(o))) : r.push(t(o));
  return { formErrors: r, fieldErrors: n };
}
function jt(e, t) {
  const n = t || function(s) {
    return s.message;
  }, r = { _errors: [] }, o = (s) => {
    for (const i of s.issues)
      if (i.code === "invalid_union" && i.errors.length)
        i.errors.map((u) => o({ issues: u }));
      else if (i.code === "invalid_key")
        o({ issues: i.issues });
      else if (i.code === "invalid_element")
        o({ issues: i.issues });
      else if (i.path.length === 0)
        r._errors.push(n(i));
      else {
        let u = r, l = 0;
        for (; l < i.path.length; ) {
          const h = i.path[l];
          l === i.path.length - 1 ? (u[h] = u[h] || { _errors: [] }, u[h]._errors.push(n(i))) : u[h] = u[h] || { _errors: [] }, u = u[h], l++;
        }
      }
  };
  return o(e), r;
}
const Ft = (e) => (t, n, r, o) => {
  const s = r ? Object.assign(r, { async: !1 }) : { async: !1 }, i = t._zod.run({ value: n, issues: [] }, s);
  if (i instanceof Promise)
    throw new C();
  if (i.issues.length) {
    const u = new (o?.Err ?? e)(i.issues.map((l) => x(l, s, T())));
    throw Ve(u, o?.callee), u;
  }
  return i.value;
}, Lt = (e) => async (t, n, r, o) => {
  const s = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let i = t._zod.run({ value: n, issues: [] }, s);
  if (i instanceof Promise && (i = await i), i.issues.length) {
    const u = new (o?.Err ?? e)(i.issues.map((l) => x(l, s, T())));
    throw Ve(u, o?.callee), u;
  }
  return i.value;
}, Ye = (e) => (t, n, r) => {
  const o = r ? { ...r, async: !1 } : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise)
    throw new C();
  return s.issues.length ? {
    success: !1,
    error: new (e ?? qe)(s.issues.map((i) => x(i, o, T())))
  } : { success: !0, data: s.value };
}, Mt = /* @__PURE__ */ Ye(He), Xe = (e) => async (t, n, r) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, o);
  return s instanceof Promise && (s = await s), s.issues.length ? {
    success: !1,
    error: new e(s.issues.map((i) => x(i, o, T())))
  } : { success: !0, data: s.value };
}, Wt = /* @__PURE__ */ Xe(He), Bt = /^[cC][^\s-]{8,}$/, Vt = /^[0-9a-z]+$/, Jt = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Kt = /^[0-9a-vA-V]{20}$/, Gt = /^[A-Za-z0-9]{27}$/, qt = /^[a-zA-Z0-9_-]{21}$/, Ht = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Yt = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, we = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, Xt = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Qt = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function en() {
  return new RegExp(Qt, "u");
}
const tn = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, nn = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, rn = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, on = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, sn = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Qe = /^[A-Za-z0-9_-]*$/, un = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, an = /^\+(?:[0-9]){6,14}[0-9]$/, et = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", cn = /* @__PURE__ */ new RegExp(`^${et}$`);
function tt(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function ln(e) {
  return new RegExp(`^${tt(e)}$`);
}
function hn(e) {
  const t = tt({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${et}T(?:${r})$`);
}
const pn = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, dn = /^\d+$/, fn = /^-?\d+(?:\.\d+)?/i, mn = /true|false/i, gn = /^[^A-Z]*$/, _n = /^[^a-z]*$/, y = /* @__PURE__ */ a("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), nt = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, rt = /* @__PURE__ */ a("$ZodCheckLessThan", (e, t) => {
  y.init(e, t);
  const n = nt[typeof t.value];
  e._zod.onattach.push((r) => {
    const o = r._zod.bag, s = (t.inclusive ? o.maximum : o.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < s && (t.inclusive ? o.maximum = t.value : o.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: n,
      code: "too_big",
      maximum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), ot = /* @__PURE__ */ a("$ZodCheckGreaterThan", (e, t) => {
  y.init(e, t);
  const n = nt[typeof t.value];
  e._zod.onattach.push((r) => {
    const o = r._zod.bag, s = (t.inclusive ? o.minimum : o.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > s && (t.inclusive ? o.minimum = t.value : o.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: n,
      code: "too_small",
      minimum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), vn = /* @__PURE__ */ a("$ZodCheckMultipleOf", (e, t) => {
  y.init(e, t), e._zod.onattach.push((n) => {
    var r;
    (r = n._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : Et(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), wn = /* @__PURE__ */ a("$ZodCheckNumberFormat", (e, t) => {
  y.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), r = n ? "int" : "number", [o, s] = Nt[t.format];
  e._zod.onattach.push((i) => {
    const u = i._zod.bag;
    u.format = t.format, u.minimum = o, u.maximum = s, n && (u.pattern = dn);
  }), e._zod.check = (i) => {
    const u = i.value;
    if (n) {
      if (!Number.isInteger(u)) {
        i.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: u,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(u)) {
        u > 0 ? i.issues.push({
          input: u,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        }) : i.issues.push({
          input: u,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        });
        return;
      }
    }
    u < o && i.issues.push({
      origin: "number",
      input: u,
      code: "too_small",
      minimum: o,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), u > s && i.issues.push({
      origin: "number",
      input: u,
      code: "too_big",
      maximum: s,
      inst: e
    });
  };
}), bn = /* @__PURE__ */ a("$ZodCheckMaxLength", (e, t) => {
  var n;
  y.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < o && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length <= t.maximum)
      return;
    const i = pe(o);
    r.issues.push({
      origin: i,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), kn = /* @__PURE__ */ a("$ZodCheckMinLength", (e, t) => {
  var n;
  y.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > o && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length >= t.minimum)
      return;
    const i = pe(o);
    r.issues.push({
      origin: i,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), zn = /* @__PURE__ */ a("$ZodCheckLengthEquals", (e, t) => {
  var n;
  y.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !le(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.minimum = t.length, o.maximum = t.length, o.length = t.length;
  }), e._zod.check = (r) => {
    const o = r.value, s = o.length;
    if (s === t.length)
      return;
    const i = pe(o), u = s > t.length;
    r.issues.push({
      origin: i,
      ...u ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Q = /* @__PURE__ */ a("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  y.init(e, t), e._zod.onattach.push((o) => {
    const s = o._zod.bag;
    s.format = t.format, t.pattern && (s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (o) => {
    t.pattern.lastIndex = 0, !t.pattern.test(o.value) && o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: o.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), $n = /* @__PURE__ */ a("$ZodCheckRegex", (e, t) => {
  Q.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), Zn = /* @__PURE__ */ a("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = gn), Q.init(e, t);
}), yn = /* @__PURE__ */ a("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = _n), Q.init(e, t);
}), En = /* @__PURE__ */ a("$ZodCheckIncludes", (e, t) => {
  y.init(e, t);
  const n = X(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((o) => {
    const s = o._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(r);
  }), e._zod.check = (o) => {
    o.value.includes(t.includes, t.position) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), In = /* @__PURE__ */ a("$ZodCheckStartsWith", (e, t) => {
  y.init(e, t);
  const n = new RegExp(`^${X(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), On = /* @__PURE__ */ a("$ZodCheckEndsWith", (e, t) => {
  y.init(e, t);
  const n = new RegExp(`.*${X(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Sn = /* @__PURE__ */ a("$ZodCheckOverwrite", (e, t) => {
  y.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class Rn {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((i) => i), o = Math.min(...r.map((i) => i.length - i.trimStart().length)), s = r.map((i) => i.slice(o)).map((i) => " ".repeat(this.indent * 2) + i);
    for (const i of s)
      this.content.push(i);
  }
  compile() {
    const t = Function, n = this?.args, o = [...(this?.content ?? [""]).map((s) => `  ${s}`)];
    return new t(...n, o.join(`
`));
  }
}
const Nn = {
  major: 4,
  minor: 0,
  patch: 17
}, w = /* @__PURE__ */ a("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Nn;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const o of r)
    for (const s of o._zod.onattach)
      s(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const o = (s, i, u) => {
      let l = D(s), h;
      for (const z of i) {
        if (z._zod.def.when) {
          if (!z._zod.def.when(s))
            continue;
        } else if (l)
          continue;
        const p = s.issues.length, f = z._zod.check(s);
        if (f instanceof Promise && u?.async === !1)
          throw new C();
        if (h || f instanceof Promise)
          h = (h ?? Promise.resolve()).then(async () => {
            await f, s.issues.length !== p && (l || (l = D(s, p)));
          });
        else {
          if (s.issues.length === p)
            continue;
          l || (l = D(s, p));
        }
      }
      return h ? h.then(() => s) : s;
    };
    e._zod.run = (s, i) => {
      const u = e._zod.parse(s, i);
      if (u instanceof Promise) {
        if (i.async === !1)
          throw new C();
        return u.then((l) => o(l, r, i));
      }
      return o(u, r, i);
    };
  }
  e["~standard"] = {
    validate: (o) => {
      try {
        const s = Mt(e, o);
        return s.success ? { value: s.data } : { issues: s.error?.issues };
      } catch {
        return Wt(e, o).then((i) => i.success ? { value: i.data } : { issues: i.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), de = /* @__PURE__ */ a("$ZodString", (e, t) => {
  w.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? pn(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), g = /* @__PURE__ */ a("$ZodStringFormat", (e, t) => {
  Q.init(e, t), de.init(e, t);
}), Tn = /* @__PURE__ */ a("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Yt), g.init(e, t);
}), xn = /* @__PURE__ */ a("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = we(r));
  } else
    t.pattern ?? (t.pattern = we());
  g.init(e, t);
}), Pn = /* @__PURE__ */ a("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Xt), g.init(e, t);
}), An = /* @__PURE__ */ a("$ZodURL", (e, t) => {
  g.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), o = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(o.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: un.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = o.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Un = /* @__PURE__ */ a("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = en()), g.init(e, t);
}), Dn = /* @__PURE__ */ a("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = qt), g.init(e, t);
}), Cn = /* @__PURE__ */ a("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Bt), g.init(e, t);
}), jn = /* @__PURE__ */ a("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = Vt), g.init(e, t);
}), Fn = /* @__PURE__ */ a("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Jt), g.init(e, t);
}), Ln = /* @__PURE__ */ a("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Kt), g.init(e, t);
}), Mn = /* @__PURE__ */ a("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Gt), g.init(e, t);
}), Wn = /* @__PURE__ */ a("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = hn(t)), g.init(e, t);
}), Bn = /* @__PURE__ */ a("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = cn), g.init(e, t);
}), Vn = /* @__PURE__ */ a("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = ln(t)), g.init(e, t);
}), Jn = /* @__PURE__ */ a("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Ht), g.init(e, t);
}), Kn = /* @__PURE__ */ a("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = tn), g.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv4";
  });
}), Gn = /* @__PURE__ */ a("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = nn), g.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv6";
  }), e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), qn = /* @__PURE__ */ a("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = rn), g.init(e, t);
}), Hn = /* @__PURE__ */ a("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = on), g.init(e, t), e._zod.check = (n) => {
    const [r, o] = n.value.split("/");
    try {
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${r}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function st(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const Yn = /* @__PURE__ */ a("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = sn), g.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (n) => {
    st(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Xn(e) {
  if (!Qe.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return st(n);
}
const Qn = /* @__PURE__ */ a("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Qe), g.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (n) => {
    Xn(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), er = /* @__PURE__ */ a("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = an), g.init(e, t);
});
function tr(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const o = JSON.parse(atob(r));
    return !("typ" in o && o?.typ !== "JWT" || !o.alg || t && (!("alg" in o) || o.alg !== t));
  } catch {
    return !1;
  }
}
const nr = /* @__PURE__ */ a("$ZodJWT", (e, t) => {
  g.init(e, t), e._zod.check = (n) => {
    tr(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), it = /* @__PURE__ */ a("$ZodNumber", (e, t) => {
  w.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? fn, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const o = n.value;
    if (typeof o == "number" && !Number.isNaN(o) && Number.isFinite(o))
      return n;
    const s = typeof o == "number" ? Number.isNaN(o) ? "NaN" : Number.isFinite(o) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: o,
      inst: e,
      ...s ? { received: s } : {}
    }), n;
  };
}), rr = /* @__PURE__ */ a("$ZodNumber", (e, t) => {
  wn.init(e, t), it.init(e, t);
}), or = /* @__PURE__ */ a("$ZodBoolean", (e, t) => {
  w.init(e, t), e._zod.pattern = mn, e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const o = n.value;
    return typeof o == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: o,
      inst: e
    }), n;
  };
}), sr = /* @__PURE__ */ a("$ZodUnknown", (e, t) => {
  w.init(e, t), e._zod.parse = (n) => n;
}), ir = /* @__PURE__ */ a("$ZodNever", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function be(e, t, n) {
  e.issues.length && t.issues.push(...Ke(n, e.issues)), t.value[n] = e.value;
}
const ur = /* @__PURE__ */ a("$ZodArray", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value;
    if (!Array.isArray(o))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: o,
        inst: e
      }), n;
    n.value = Array(o.length);
    const s = [];
    for (let i = 0; i < o.length; i++) {
      const u = o[i], l = t.element._zod.run({
        value: u,
        issues: []
      }, r);
      l instanceof Promise ? s.push(l.then((h) => be(h, n, i))) : be(l, n, i);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function V(e, t, n, r) {
  e.issues.length && t.issues.push(...Ke(n, e.issues)), e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
const ar = /* @__PURE__ */ a("$ZodObject", (e, t) => {
  w.init(e, t);
  const n = Be(() => {
    const p = Object.keys(t.shape);
    for (const m of p)
      if (!t.shape[m]._zod.traits.has("$ZodType"))
        throw new Error(`Invalid element at key "${m}": expected a Zod schema`);
    const f = Rt(t.shape);
    return {
      shape: t.shape,
      keys: p,
      keySet: new Set(p),
      numKeys: p.length,
      optionalKeys: new Set(f)
    };
  });
  d(e._zod, "propValues", () => {
    const p = t.shape, f = {};
    for (const m in p) {
      const E = p[m]._zod;
      if (E.values) {
        f[m] ?? (f[m] = /* @__PURE__ */ new Set());
        for (const S of E.values)
          f[m].add(S);
      }
    }
    return f;
  });
  const r = (p) => {
    const f = new Rn(["shape", "payload", "ctx"]), m = n.value, E = (I) => {
      const k = ve(I);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    f.write("const input = payload.value;");
    const S = /* @__PURE__ */ Object.create(null);
    let te = 0;
    for (const I of m.keys)
      S[I] = `key_${te++}`;
    f.write("const newResult = {}");
    for (const I of m.keys) {
      const k = S[I], Z = ve(I);
      f.write(`const ${k} = ${E(I)};`), f.write(`
        if (${k}.issues.length) {
          payload.issues = payload.issues.concat(${k}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Z}, ...iss.path] : [${Z}]
          })));
        }
        
        if (${k}.value === undefined) {
          if (${Z} in input) {
            newResult[${Z}] = undefined;
          }
        } else {
          newResult[${Z}] = ${k}.value;
        }
      `);
    }
    f.write("payload.value = newResult;"), f.write("return payload;");
    const L = f.compile();
    return (I, k) => L(p, I, k);
  };
  let o;
  const s = ue, i = !We.jitless, l = i && Ot.value, h = t.catchall;
  let z;
  e._zod.parse = (p, f) => {
    z ?? (z = n.value);
    const m = p.value;
    if (!s(m))
      return p.issues.push({
        expected: "object",
        code: "invalid_type",
        input: m,
        inst: e
      }), p;
    const E = [];
    if (i && l && f?.async === !1 && f.jitless !== !0)
      o || (o = r(t.shape)), p = o(p, f);
    else {
      p.value = {};
      const k = z.shape;
      for (const Z of z.keys) {
        const ne = k[Z]._zod.run({ value: m[Z], issues: [] }, f);
        ne instanceof Promise ? E.push(ne.then((vt) => V(vt, p, Z, m))) : V(ne, p, Z, m);
      }
    }
    if (!h)
      return E.length ? Promise.all(E).then(() => p) : p;
    const S = [], te = z.keySet, L = h._zod, I = L.def.type;
    for (const k of Object.keys(m)) {
      if (te.has(k))
        continue;
      if (I === "never") {
        S.push(k);
        continue;
      }
      const Z = L.run({ value: m[k], issues: [] }, f);
      Z instanceof Promise ? E.push(Z.then((ge) => V(ge, p, k, m))) : V(Z, p, k, m);
    }
    return S.length && p.issues.push({
      code: "unrecognized_keys",
      keys: S,
      input: m,
      inst: e
    }), E.length ? Promise.all(E).then(() => p) : p;
  };
});
function ke(e, t, n, r) {
  for (const s of e)
    if (s.issues.length === 0)
      return t.value = s.value, t;
  const o = e.filter((s) => !D(s));
  return o.length === 1 ? (t.value = o[0].value, o[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((s) => s.issues.map((i) => x(i, r, T())))
  }), t);
}
const cr = /* @__PURE__ */ a("$ZodUnion", (e, t) => {
  w.init(e, t), d(e._zod, "optin", () => t.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), d(e._zod, "optout", () => t.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), d(e._zod, "values", () => {
    if (t.options.every((o) => o._zod.values))
      return new Set(t.options.flatMap((o) => Array.from(o._zod.values)));
  }), d(e._zod, "pattern", () => {
    if (t.options.every((o) => o._zod.pattern)) {
      const o = t.options.map((s) => s._zod.pattern);
      return new RegExp(`^(${o.map((s) => he(s.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (o, s) => {
    if (n)
      return r(o, s);
    let i = !1;
    const u = [];
    for (const l of t.options) {
      const h = l._zod.run({
        value: o.value,
        issues: []
      }, s);
      if (h instanceof Promise)
        u.push(h), i = !0;
      else {
        if (h.issues.length === 0)
          return h;
        u.push(h);
      }
    }
    return i ? Promise.all(u).then((l) => ke(l, o, e, s)) : ke(u, o, e, s);
  };
}), lr = /* @__PURE__ */ a("$ZodIntersection", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value, s = t.left._zod.run({ value: o, issues: [] }, r), i = t.right._zod.run({ value: o, issues: [] }, r);
    return s instanceof Promise || i instanceof Promise ? Promise.all([s, i]).then(([l, h]) => ze(n, l, h)) : ze(n, s, i);
  };
});
function ae(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (q(e) && q(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((s) => n.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of r) {
      const i = ae(e[s], t[s]);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...i.mergeErrorPath]
        };
      o[s] = i.data;
    }
    return { valid: !0, data: o };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], s = t[r], i = ae(o, s);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...i.mergeErrorPath]
        };
      n.push(i.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function ze(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), D(e))
    return e;
  const r = ae(t.value, n.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
const hr = /* @__PURE__ */ a("$ZodEnum", (e, t) => {
  w.init(e, t);
  const n = yt(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((o) => St.has(typeof o)).map((o) => typeof o == "string" ? X(o) : o.toString()).join("|")})$`), e._zod.parse = (o, s) => {
    const i = o.value;
    return r.has(i) || o.issues.push({
      code: "invalid_value",
      values: n,
      input: i,
      inst: e
    }), o;
  };
}), pr = /* @__PURE__ */ a("$ZodTransform", (e, t) => {
  w.init(e, t), e._zod.parse = (n, r) => {
    const o = t.transform(n.value, n);
    if (r.async)
      return (o instanceof Promise ? o : Promise.resolve(o)).then((i) => (n.value = i, n));
    if (o instanceof Promise)
      throw new C();
    return n.value = o, n;
  };
});
function $e(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const dr = /* @__PURE__ */ a("$ZodOptional", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", d(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), d(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${he(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => {
    if (t.innerType._zod.optin === "optional") {
      const o = t.innerType._zod.run(n, r);
      return o instanceof Promise ? o.then((s) => $e(s, n.value)) : $e(o, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, r);
  };
}), fr = /* @__PURE__ */ a("$ZodNullable", (e, t) => {
  w.init(e, t), d(e._zod, "optin", () => t.innerType._zod.optin), d(e._zod, "optout", () => t.innerType._zod.optout), d(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${he(n.source)}|null)$`) : void 0;
  }), d(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), mr = /* @__PURE__ */ a("$ZodDefault", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", d(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => Ze(s, t)) : Ze(o, t);
  };
});
function Ze(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const gr = /* @__PURE__ */ a("$ZodPrefault", (e, t) => {
  w.init(e, t), e._zod.optin = "optional", d(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), _r = /* @__PURE__ */ a("$ZodNonOptional", (e, t) => {
  w.init(e, t), d(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => ye(s, e)) : ye(o, e);
  };
});
function ye(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const vr = /* @__PURE__ */ a("$ZodCatch", (e, t) => {
  w.init(e, t), d(e._zod, "optin", () => t.innerType._zod.optin), d(e._zod, "optout", () => t.innerType._zod.optout), d(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => (n.value = s.value, s.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: s.issues.map((i) => x(i, r, T()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((s) => x(s, r, T()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), wr = /* @__PURE__ */ a("$ZodPipe", (e, t) => {
  w.init(e, t), d(e._zod, "values", () => t.in._zod.values), d(e._zod, "optin", () => t.in._zod.optin), d(e._zod, "optout", () => t.out._zod.optout), d(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    const o = t.in._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => Ee(s, t, r)) : Ee(o, t, r);
  };
});
function Ee(e, t, n) {
  return e.issues.length ? e : t.out._zod.run({ value: e.value, issues: e.issues }, n);
}
const br = /* @__PURE__ */ a("$ZodReadonly", (e, t) => {
  w.init(e, t), d(e._zod, "propValues", () => t.innerType._zod.propValues), d(e._zod, "values", () => t.innerType._zod.values), d(e._zod, "optin", () => t.innerType._zod.optin), d(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then(Ie) : Ie(o);
  };
});
function Ie(e) {
  return e.value = Object.freeze(e.value), e;
}
const kr = /* @__PURE__ */ a("$ZodCustom", (e, t) => {
  y.init(e, t), w.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, o = t.fn(r);
    if (o instanceof Promise)
      return o.then((s) => Oe(s, n, r, e));
    Oe(o, n, r, e);
  };
});
function Oe(e, t, n, r) {
  if (!e) {
    const o = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (o.params = r._zod.def.params), t.issues.push(j(o));
  }
}
class zr {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    if (this._map.set(t, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const o = { ...r, ...this._map.get(t) };
      return Object.keys(o).length ? o : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function $r() {
  return new zr();
}
const J = /* @__PURE__ */ $r();
function Zr(e, t) {
  return new e({
    type: "string",
    ...c(t)
  });
}
function yr(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Se(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Er(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Ir(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...c(t)
  });
}
function Or(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...c(t)
  });
}
function Sr(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...c(t)
  });
}
function ut(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Rr(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Nr(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Tr(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function xr(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Pr(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Ar(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Ur(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Dr(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Cr(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function jr(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Fr(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Lr(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Mr(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Wr(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Br(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...c(t)
  });
}
function Vr(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...c(t)
  });
}
function Jr(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...c(t)
  });
}
function Kr(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...c(t)
  });
}
function Gr(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...c(t)
  });
}
function qr(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...c(t)
  });
}
function Hr(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...c(t)
  });
}
function Yr(e, t) {
  return new e({
    type: "boolean",
    ...c(t)
  });
}
function Xr(e) {
  return new e({
    type: "unknown"
  });
}
function Qr(e, t) {
  return new e({
    type: "never",
    ...c(t)
  });
}
function Re(e, t) {
  return new rt({
    check: "less_than",
    ...c(t),
    value: e,
    inclusive: !1
  });
}
function oe(e, t) {
  return new rt({
    check: "less_than",
    ...c(t),
    value: e,
    inclusive: !0
  });
}
function Ne(e, t) {
  return new ot({
    check: "greater_than",
    ...c(t),
    value: e,
    inclusive: !1
  });
}
function se(e, t) {
  return new ot({
    check: "greater_than",
    ...c(t),
    value: e,
    inclusive: !0
  });
}
function Te(e, t) {
  return new vn({
    check: "multiple_of",
    ...c(t),
    value: e
  });
}
function at(e, t) {
  return new bn({
    check: "max_length",
    ...c(t),
    maximum: e
  });
}
function H(e, t) {
  return new kn({
    check: "min_length",
    ...c(t),
    minimum: e
  });
}
function ct(e, t) {
  return new zn({
    check: "length_equals",
    ...c(t),
    length: e
  });
}
function eo(e, t) {
  return new $n({
    check: "string_format",
    format: "regex",
    ...c(t),
    pattern: e
  });
}
function to(e) {
  return new Zn({
    check: "string_format",
    format: "lowercase",
    ...c(e)
  });
}
function no(e) {
  return new yn({
    check: "string_format",
    format: "uppercase",
    ...c(e)
  });
}
function ro(e, t) {
  return new En({
    check: "string_format",
    format: "includes",
    ...c(t),
    includes: e
  });
}
function oo(e, t) {
  return new In({
    check: "string_format",
    format: "starts_with",
    ...c(t),
    prefix: e
  });
}
function so(e, t) {
  return new On({
    check: "string_format",
    format: "ends_with",
    ...c(t),
    suffix: e
  });
}
function F(e) {
  return new Sn({
    check: "overwrite",
    tx: e
  });
}
function io(e) {
  return F((t) => t.normalize(e));
}
function uo() {
  return F((e) => e.trim());
}
function ao() {
  return F((e) => e.toLowerCase());
}
function co() {
  return F((e) => e.toUpperCase());
}
function lo(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...c(n)
  });
}
function ho(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...c(n)
  });
}
function po(e) {
  const t = fo((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(j(r, n.value, t._zod.def));
    else {
      const o = r;
      o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = n.value), o.inst ?? (o.inst = t), o.continue ?? (o.continue = !t._zod.def.abort), n.issues.push(j(o));
    }
  }, e(n.value, n)));
  return t;
}
function fo(e, t) {
  const n = new y({
    check: "custom",
    ...c(t)
  });
  return n._zod.check = e, n;
}
const mo = /* @__PURE__ */ a("ZodISODateTime", (e, t) => {
  Wn.init(e, t), _.init(e, t);
});
function go(e) {
  return Vr(mo, e);
}
const _o = /* @__PURE__ */ a("ZodISODate", (e, t) => {
  Bn.init(e, t), _.init(e, t);
});
function vo(e) {
  return Jr(_o, e);
}
const wo = /* @__PURE__ */ a("ZodISOTime", (e, t) => {
  Vn.init(e, t), _.init(e, t);
});
function bo(e) {
  return Kr(wo, e);
}
const ko = /* @__PURE__ */ a("ZodISODuration", (e, t) => {
  Jn.init(e, t), _.init(e, t);
});
function zo(e) {
  return Gr(ko, e);
}
const lt = (e, t) => {
  qe.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => jt(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Ct(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, ie, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, ie, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, xe = a("ZodError", lt), ee = a("ZodError", lt, {
  Parent: Error
}), $o = /* @__PURE__ */ Ft(ee), Zo = /* @__PURE__ */ Lt(ee), yo = /* @__PURE__ */ Ye(ee), Eo = /* @__PURE__ */ Xe(ee), b = /* @__PURE__ */ a("ZodType", (e, t) => (w.init(e, t), e.def = t, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
    ]
  }
  // { parent: true }
), e.clone = (n, r) => A(e, n, r), e.brand = () => e, e.register = ((n, r) => (n.add(e, r), e)), e.parse = (n, r) => $o(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => yo(e, n, r), e.parseAsync = async (n, r) => Zo(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => Eo(e, n, r), e.spa = e.safeParseAsync, e.refine = (n, r) => e.check(gs(n, r)), e.superRefine = (n) => e.check(_s(n)), e.overwrite = (n) => e.check(F(n)), e.optional = () => Ce(e), e.nullable = () => je(e), e.nullish = () => Ce(je(e)), e.nonoptional = (n) => cs(e, n), e.array = () => fe(e), e.or = (n) => Xo([e, n]), e.and = (n) => es(e, n), e.transform = (n) => Fe(e, rs(n)), e.default = (n) => is(e, n), e.prefault = (n) => as(e, n), e.catch = (n) => hs(e, n), e.pipe = (n) => Fe(e, n), e.readonly = () => fs(e), e.describe = (n) => {
  const r = e.clone();
  return J.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return J.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return J.get(e);
  const r = e.clone();
  return J.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), ht = /* @__PURE__ */ a("_ZodString", (e, t) => {
  de.init(e, t), b.init(e, t);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(eo(...r)), e.includes = (...r) => e.check(ro(...r)), e.startsWith = (...r) => e.check(oo(...r)), e.endsWith = (...r) => e.check(so(...r)), e.min = (...r) => e.check(H(...r)), e.max = (...r) => e.check(at(...r)), e.length = (...r) => e.check(ct(...r)), e.nonempty = (...r) => e.check(H(1, ...r)), e.lowercase = (r) => e.check(to(r)), e.uppercase = (r) => e.check(no(r)), e.trim = () => e.check(uo()), e.normalize = (...r) => e.check(io(...r)), e.toLowerCase = () => e.check(ao()), e.toUpperCase = () => e.check(co());
}), Io = /* @__PURE__ */ a("ZodString", (e, t) => {
  de.init(e, t), ht.init(e, t), e.email = (n) => e.check(yr(Oo, n)), e.url = (n) => e.check(ut(pt, n)), e.jwt = (n) => e.check(Br(Wo, n)), e.emoji = (n) => e.check(Rr(So, n)), e.guid = (n) => e.check(Se(Pe, n)), e.uuid = (n) => e.check(Er(K, n)), e.uuidv4 = (n) => e.check(Ir(K, n)), e.uuidv6 = (n) => e.check(Or(K, n)), e.uuidv7 = (n) => e.check(Sr(K, n)), e.nanoid = (n) => e.check(Nr(Ro, n)), e.guid = (n) => e.check(Se(Pe, n)), e.cuid = (n) => e.check(Tr(No, n)), e.cuid2 = (n) => e.check(xr(To, n)), e.ulid = (n) => e.check(Pr(xo, n)), e.base64 = (n) => e.check(Lr(Fo, n)), e.base64url = (n) => e.check(Mr(Lo, n)), e.xid = (n) => e.check(Ar(Po, n)), e.ksuid = (n) => e.check(Ur(Ao, n)), e.ipv4 = (n) => e.check(Dr(Uo, n)), e.ipv6 = (n) => e.check(Cr(Do, n)), e.cidrv4 = (n) => e.check(jr(Co, n)), e.cidrv6 = (n) => e.check(Fr(jo, n)), e.e164 = (n) => e.check(Wr(Mo, n)), e.datetime = (n) => e.check(go(n)), e.date = (n) => e.check(vo(n)), e.time = (n) => e.check(bo(n)), e.duration = (n) => e.check(zo(n));
});
function $(e) {
  return Zr(Io, e);
}
const _ = /* @__PURE__ */ a("ZodStringFormat", (e, t) => {
  g.init(e, t), ht.init(e, t);
}), Oo = /* @__PURE__ */ a("ZodEmail", (e, t) => {
  Pn.init(e, t), _.init(e, t);
}), Pe = /* @__PURE__ */ a("ZodGUID", (e, t) => {
  Tn.init(e, t), _.init(e, t);
}), K = /* @__PURE__ */ a("ZodUUID", (e, t) => {
  xn.init(e, t), _.init(e, t);
}), pt = /* @__PURE__ */ a("ZodURL", (e, t) => {
  An.init(e, t), _.init(e, t);
});
function Ae(e) {
  return ut(pt, e);
}
const So = /* @__PURE__ */ a("ZodEmoji", (e, t) => {
  Un.init(e, t), _.init(e, t);
}), Ro = /* @__PURE__ */ a("ZodNanoID", (e, t) => {
  Dn.init(e, t), _.init(e, t);
}), No = /* @__PURE__ */ a("ZodCUID", (e, t) => {
  Cn.init(e, t), _.init(e, t);
}), To = /* @__PURE__ */ a("ZodCUID2", (e, t) => {
  jn.init(e, t), _.init(e, t);
}), xo = /* @__PURE__ */ a("ZodULID", (e, t) => {
  Fn.init(e, t), _.init(e, t);
}), Po = /* @__PURE__ */ a("ZodXID", (e, t) => {
  Ln.init(e, t), _.init(e, t);
}), Ao = /* @__PURE__ */ a("ZodKSUID", (e, t) => {
  Mn.init(e, t), _.init(e, t);
}), Uo = /* @__PURE__ */ a("ZodIPv4", (e, t) => {
  Kn.init(e, t), _.init(e, t);
}), Do = /* @__PURE__ */ a("ZodIPv6", (e, t) => {
  Gn.init(e, t), _.init(e, t);
}), Co = /* @__PURE__ */ a("ZodCIDRv4", (e, t) => {
  qn.init(e, t), _.init(e, t);
}), jo = /* @__PURE__ */ a("ZodCIDRv6", (e, t) => {
  Hn.init(e, t), _.init(e, t);
}), Fo = /* @__PURE__ */ a("ZodBase64", (e, t) => {
  Yn.init(e, t), _.init(e, t);
}), Lo = /* @__PURE__ */ a("ZodBase64URL", (e, t) => {
  Qn.init(e, t), _.init(e, t);
}), Mo = /* @__PURE__ */ a("ZodE164", (e, t) => {
  er.init(e, t), _.init(e, t);
}), Wo = /* @__PURE__ */ a("ZodJWT", (e, t) => {
  nr.init(e, t), _.init(e, t);
}), dt = /* @__PURE__ */ a("ZodNumber", (e, t) => {
  it.init(e, t), b.init(e, t), e.gt = (r, o) => e.check(Ne(r, o)), e.gte = (r, o) => e.check(se(r, o)), e.min = (r, o) => e.check(se(r, o)), e.lt = (r, o) => e.check(Re(r, o)), e.lte = (r, o) => e.check(oe(r, o)), e.max = (r, o) => e.check(oe(r, o)), e.int = (r) => e.check(Ue(r)), e.safe = (r) => e.check(Ue(r)), e.positive = (r) => e.check(Ne(0, r)), e.nonnegative = (r) => e.check(se(0, r)), e.negative = (r) => e.check(Re(0, r)), e.nonpositive = (r) => e.check(oe(0, r)), e.multipleOf = (r, o) => e.check(Te(r, o)), e.step = (r, o) => e.check(Te(r, o)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function ft(e) {
  return qr(dt, e);
}
const Bo = /* @__PURE__ */ a("ZodNumberFormat", (e, t) => {
  rr.init(e, t), dt.init(e, t);
});
function Ue(e) {
  return Hr(Bo, e);
}
const Vo = /* @__PURE__ */ a("ZodBoolean", (e, t) => {
  or.init(e, t), b.init(e, t);
});
function mt(e) {
  return Yr(Vo, e);
}
const Jo = /* @__PURE__ */ a("ZodUnknown", (e, t) => {
  sr.init(e, t), b.init(e, t);
});
function De() {
  return Xr(Jo);
}
const Ko = /* @__PURE__ */ a("ZodNever", (e, t) => {
  ir.init(e, t), b.init(e, t);
});
function Go(e) {
  return Qr(Ko, e);
}
const qo = /* @__PURE__ */ a("ZodArray", (e, t) => {
  ur.init(e, t), b.init(e, t), e.element = t.element, e.min = (n, r) => e.check(H(n, r)), e.nonempty = (n) => e.check(H(1, n)), e.max = (n, r) => e.check(at(n, r)), e.length = (n, r) => e.check(ct(n, r)), e.unwrap = () => e.element;
});
function fe(e, t) {
  return lo(qo, e, t);
}
const Ho = /* @__PURE__ */ a("ZodObject", (e, t) => {
  ar.init(e, t), b.init(e, t), d(e, "shape", () => t.shape), e.keyof = () => ts(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: De() }), e.loose = () => e.clone({ ...e._zod.def, catchall: De() }), e.strict = () => e.clone({ ...e._zod.def, catchall: Go() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Pt(e, n), e.merge = (n) => At(e, n), e.pick = (n) => Tt(e, n), e.omit = (n) => xt(e, n), e.partial = (...n) => Ut(gt, e, n[0]), e.required = (...n) => Dt(_t, e, n[0]);
});
function N(e, t) {
  const n = {
    type: "object",
    get shape() {
      return P(this, "shape", e ? It(e) : {}), this.shape;
    },
    ...c(t)
  };
  return new Ho(n);
}
const Yo = /* @__PURE__ */ a("ZodUnion", (e, t) => {
  cr.init(e, t), b.init(e, t), e.options = t.options;
});
function Xo(e, t) {
  return new Yo({
    type: "union",
    options: e,
    ...c(t)
  });
}
const Qo = /* @__PURE__ */ a("ZodIntersection", (e, t) => {
  lr.init(e, t), b.init(e, t);
});
function es(e, t) {
  return new Qo({
    type: "intersection",
    left: e,
    right: t
  });
}
const ce = /* @__PURE__ */ a("ZodEnum", (e, t) => {
  hr.init(e, t), b.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, o) => {
    const s = {};
    for (const i of r)
      if (n.has(i))
        s[i] = t.entries[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...c(o),
      entries: s
    });
  }, e.exclude = (r, o) => {
    const s = { ...t.entries };
    for (const i of r)
      if (n.has(i))
        delete s[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...c(o),
      entries: s
    });
  };
});
function ts(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new ce({
    type: "enum",
    entries: n,
    ...c(t)
  });
}
const ns = /* @__PURE__ */ a("ZodTransform", (e, t) => {
  pr.init(e, t), b.init(e, t), e._zod.parse = (n, r) => {
    n.addIssue = (s) => {
      if (typeof s == "string")
        n.issues.push(j(s, n.value, t));
      else {
        const i = s;
        i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = e), n.issues.push(j(i));
      }
    };
    const o = t.transform(n.value, n);
    return o instanceof Promise ? o.then((s) => (n.value = s, n)) : (n.value = o, n);
  };
});
function rs(e) {
  return new ns({
    type: "transform",
    transform: e
  });
}
const gt = /* @__PURE__ */ a("ZodOptional", (e, t) => {
  dr.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ce(e) {
  return new gt({
    type: "optional",
    innerType: e
  });
}
const os = /* @__PURE__ */ a("ZodNullable", (e, t) => {
  fr.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function je(e) {
  return new os({
    type: "nullable",
    innerType: e
  });
}
const ss = /* @__PURE__ */ a("ZodDefault", (e, t) => {
  mr.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function is(e, t) {
  return new ss({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Je(t);
    }
  });
}
const us = /* @__PURE__ */ a("ZodPrefault", (e, t) => {
  gr.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function as(e, t) {
  return new us({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : Je(t);
    }
  });
}
const _t = /* @__PURE__ */ a("ZodNonOptional", (e, t) => {
  _r.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function cs(e, t) {
  return new _t({
    type: "nonoptional",
    innerType: e,
    ...c(t)
  });
}
const ls = /* @__PURE__ */ a("ZodCatch", (e, t) => {
  vr.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function hs(e, t) {
  return new ls({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const ps = /* @__PURE__ */ a("ZodPipe", (e, t) => {
  wr.init(e, t), b.init(e, t), e.in = t.in, e.out = t.out;
});
function Fe(e, t) {
  return new ps({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const ds = /* @__PURE__ */ a("ZodReadonly", (e, t) => {
  br.init(e, t), b.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function fs(e) {
  return new ds({
    type: "readonly",
    innerType: e
  });
}
const ms = /* @__PURE__ */ a("ZodCustom", (e, t) => {
  kr.init(e, t), b.init(e, t);
});
function gs(e, t = {}) {
  return ho(ms, e, t);
}
function _s(e) {
  return po(e);
}
const vs = N({
  title: $().max(256).optional(),
  description: $().max(4096).optional(),
  url: Ae().optional(),
  color: ft().int().min(0).max(16777215).optional(),
  timestamp: $().datetime().optional(),
  author: N({
    name: $().max(256),
    url: Ae().optional(),
    icon_url: $().url().optional()
  }).optional(),
  footer: N({
    text: $().max(2048),
    icon_url: $().url().optional()
  }).optional(),
  image: N({
    url: $().url()
  }).optional(),
  thumbnail: N({
    url: $().url()
  }).optional(),
  fields: fe(
    N({
      name: $().max(256),
      value: $().max(1024),
      inline: mt().optional()
    })
  ).max(25).optional()
}), Le = N({
  content: $().max(2e3).optional(),
  username: $().optional(),
  avatar_url: $().url().optional(),
  tts: mt().optional(),
  embeds: fe(vs).max(10).optional(),
  thread_name: $().optional(),
  flags: ft().int().optional()
}).refine(
  (e) => {
    const t = !!e.content?.trim();
    return !!e.embeds?.length && e.embeds ? t || e.embeds.some(
      (r) => r.title || r.description || r.fields?.length || r.author || r.footer || r.image || r.thumbnail
    ) : t;
  },
  {
    message: "Message must have content or at least one non-empty embed."
  }
);
class v extends Error {
  code;
  details;
  // New property for structured error details
  constructor(t, n = "WEBHOOK_ERROR", r) {
    super(t), this.name = "WebhookError", this.code = n, this.details = r, Object.setPrototypeOf(this, v.prototype);
  }
}
class Y extends v {
  issues;
  constructor(t, n = null) {
    super(t, "VALIDATION_ERROR"), this.name = "ValidationError", this.issues = n, Object.setPrototypeOf(this, Y.prototype);
  }
  /**
   * Formats Zod issues into a more readable string.
   */
  formatIssues() {
    return !this.issues || this.issues.length === 0 ? "" : this.issues.map((t) => {
      const n = t.path.join(".");
      return n ? `${n}: ${t.message}` : t.message;
    }).join("; ");
  }
}
class O extends v {
  status;
  discordMessage;
  constructor(t, n, r, o = "REQUEST_ERROR") {
    super(t, o), this.name = "RequestError", this.status = n, this.discordMessage = r, Object.setPrototypeOf(this, O.prototype);
  }
}
class me extends v {
  constructor(t, n = "FILE_SYSTEM_ERROR") {
    super(t, n), this.name = "FileSystemError", Object.setPrototypeOf(this, me.prototype);
  }
}
function Me(e) {
  return new Promise((t) => {
    setTimeout(t, e * 1e3);
  });
}
class R {
  constructor(t) {
    this.client = t;
  }
  /**
   * The number of request attempts made.
   */
  retries = 1;
  /**
   * Send the HTTP request.
   *
   * @param method - The HTTP method to use. Defaults to 'GET'.
   * @param data - The data to send with the request.
   * @param headers - Optional headers for the request.
   * @param url - Optional URL for the request. If not provided, axios baseURL will be used.
   * @returns A Promise that resolves with the response data, or rejects with an Error if an error occurs.
   * @throws {Error} if an error occurs.
   */
  async send(t = "GET", n, r, o) {
    try {
      const s = await this.client.request({
        method: t,
        url: o,
        data: n,
        headers: r
      });
      if (s.status === 429 && this.retries <= 60) {
        this.retries++;
        const i = parseInt(
          s.headers["x-ratelimit-reset-after"] ?? "3",
          10
        );
        return await Me(i), this.send(t, n, r, o);
      }
      return this.retries = 1, s.status === 204 ? void 0 : s.data;
    } catch (s) {
      if (s instanceof bt) {
        const i = s.response?.data?.message, u = s.response?.data?.code, l = s.response?.data?.errors;
        if (s.response?.status === 429) {
          const h = s.response?.data?.retry_after || parseInt(
            s.response?.headers?.["x-ratelimit-reset-after"] ?? "3",
            10
          );
          if (this.retries <= 60)
            return this.retries++, await Me(h), this.send(t, n, r, o);
          throw new O(
            `Rate limit exceeded after ${this.retries - 1} retries.`,
            429,
            i,
            "RATE_LIMIT_EXCEEDED"
          );
        }
        switch (s.response?.status) {
          case 400: {
            let h = "Bad Request.";
            throw Number(u) === 50035 ? h = `Invalid Form Body: ${JSON.stringify(l)}` : i && (h = `Bad Request: ${i}`), new O(
              h,
              400,
              i,
              u || "BAD_REQUEST"
            );
          }
          case 401:
            throw new O(
              "Unauthorized: Invalid or missing Authorization header.",
              401,
              i,
              u || "UNAUTHORIZED"
            );
          case 403:
            throw new O(
              "Forbidden: You do not have permission to perform this action.",
              403,
              i,
              u || "FORBIDDEN"
            );
          case 404:
            throw new O(
              "Webhook not found or invalid.",
              404,
              i,
              u || "WEBHOOK_NOT_FOUND"
            );
          case 413:
            throw new O(
              "Payload Too Large: The request payload exceeds Discord's size limit.",
              413,
              i,
              u || "PAYLOAD_TOO_LARGE"
            );
          default:
            throw new O(
              `Request failed with status ${s.response?.status || "unknown"}: ${i || s.message}`,
              s.response?.status,
              i,
              u || "UNKNOWN_REQUEST_ERROR"
            );
        }
      } else
        throw new O(`An unknown error occurred: ${String(s)}`);
    }
  }
}
const G = {
  INFO: 3447003,
  // Blue
  SUCCESS: 3066993,
  // Green
  WARNING: 15844367,
  // Yellow
  ERROR: 15158332
};
class ws {
  webhooks = [];
  messages = [];
  /**
   * Creates a new Webhook instance.
   * @param url The full Discord webhook URL or an array of URLs.
   * @throws {WebhookError} If any webhook URL is invalid or empty.
   */
  constructor(t) {
    t && (Array.isArray(t) ? t : [t]).forEach((r) => this.addWebhookUrl(r));
  }
  /**
   * Adds a webhook URL to the instance.
   * @param url The full Discord webhook URL.
   * @throws {WebhookError} If the webhook URL is invalid or empty.
   */
  addWebhookUrl(t) {
    const n = t.split("/");
    if (n.length < 2)
      throw new v("Invalid Webhook URL provided.", "INVALID_URL");
    const r = n[n.length - 2], o = n[n.length - 1], s = wt.create({
      baseURL: `https://discord.com/api/webhooks/${r}/${o}`,
      headers: {
        "Content-Type": "application/json"
      }
    });
    this.webhooks.push({
      id: r,
      token: o,
      url: t,
      axiosInstance: s
    });
  }
  /**
   * Returns the number of configured webhook URLs.
   * @returns The number of webhook URLs.
   */
  getWebhookCount() {
    return this.webhooks.length;
  }
  /**
   * Returns an array of all configured webhook URLs.
   * @returns An array of webhook URLs.
   **/
  getWebhookUrls() {
    return this.webhooks.map((t) => t.url);
  }
  /**
   * Adds a message to the webhook's queue for batch sending.
   * @param message The Message object to add to the queue.
   * @returns The current Webhook instance.
   */
  addMessage(t) {
    return this.messages.push(t), this;
  }
  /**
   * Clears all messages from the webhook's queue.
   * @returns The current Webhook instance.
   */
  clearMessages() {
    return this.messages = [], this;
  }
  /**
   * Returns an array of JSON payloads for all messages currently in the queue.
   * This is useful for inspecting the payload before sending.
   * @returns An array of plain objects representing the message payloads.
   */
  getPayloads() {
    return this.messages.map((t) => t.getPayload());
  }
  /**
   * Sends all messages currently in the queue to all configured webhooks.
   * Messages are sent sequentially to each webhook. If a message fails to send to any webhook,
   * it remains in the queue, and the method will throw an error after attempting to send all messages
   * to all webhooks.
   * @throws {ValidationError} If any message fails Zod validation.
   * @throws {RequestError} If any message fails to send due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors during the sending process.
   */
  async send() {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    for (const r of this.messages)
      try {
        Le.parse(r.getPayload());
      } catch (o) {
        throw o instanceof xe ? new Y(
          "Invalid message payload provided.",
          o.issues
        ) : new v(
          `An unexpected error occurred during validation: ${String(o)}`
        );
      }
    const t = [], n = [];
    for (const r of this.webhooks) {
      const o = new R(r.axiosInstance);
      for (const s of this.messages)
        try {
          await this._sendOne(s, o);
        } catch (i) {
          t.push(s), n.push({
            // Push SendFailureDetail object
            webhookUrl: r.url,
            messagePayload: s.getPayload(),
            error: i,
            type: "message"
          });
        }
    }
    if (this.messages = t, n.length > 0) {
      const r = n.map(
        (o) => o.error instanceof Error ? o.error.message : String(o.error)
      ).join(`
`);
      throw new v(
        `Failed to send ${n.length} messages to one or more webhooks. Details:
${r}`,
        "BATCH_SEND_FAILURE",
        n
        // Pass the details array
      );
    }
  }
  async _sendOne(t, n) {
    const r = t.getPayload();
    let o = "", s = "POST";
    if (t.editTarget) {
      let i;
      const u = t.editTarget.match(/\/([0-9]+)$/);
      u ? i = u[1] : i = t.editTarget, o = `/messages/${i}`, s = "PATCH";
    }
    await n.send(
      s,
      r,
      {
        "Content-Type": "application/json"
      },
      o === "" ? void 0 : o
    );
  }
  /**
   * Sends a file to all configured webhooks.
   * @param filePath The path to the file to send.
   * @param message An optional Message object to send along with the file.
   * @throws {FileSystemError} If the file cannot be read.
   * @throws {ValidationError} If the message payload fails Zod validation.
   * @throws {RequestError} If the file sending fails due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors during the file sending process.
   */
  async sendFile(t, n) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    const r = [];
    for (const o of this.webhooks) {
      const s = new kt();
      try {
        re.accessSync(t, re.constants.R_OK), s.append("files[0]", re.createReadStream(t));
      } catch (u) {
        r.push({
          webhookUrl: o.url,
          filePath: t,
          error: new me(
            `Cannot read file at path: ${t}. Original error: ${String(u)}`,
            "FILE_READ_ERROR"
          ),
          type: "file"
        });
        continue;
      }
      if (n) {
        const u = n.getPayload();
        try {
          Le.parse(u);
        } catch (l) {
          l instanceof xe ? r.push({
            webhookUrl: o.url,
            messagePayload: u,
            error: new Y(
              "Invalid message payload provided for file attachment.",
              l.issues
            ),
            type: "file"
          }) : r.push({
            webhookUrl: o.url,
            messagePayload: u,
            error: new v(
              `An unexpected error occurred during file message validation: ${String(l)}`
            ),
            type: "file"
          });
          continue;
        }
        s.append("payload_json", JSON.stringify(u));
      }
      const i = new R(o.axiosInstance);
      try {
        await i.send("POST", s);
      } catch (u) {
        r.push({
          webhookUrl: o.url,
          messagePayload: n?.getPayload(),
          // message might be undefined
          filePath: t,
          error: u,
          type: "file"
        });
      }
    }
    if (r.length > 0) {
      const o = r.map(
        (s) => s.error instanceof Error ? s.error.message : String(s.error)
      ).join(`
`);
      throw new v(
        `Failed to send file to one or more webhooks. Details:
${o}`,
        "FILE_SEND_FAILURE",
        r
        // Pass the details array
      );
    }
  }
  /**
   * Sends an informational message with a blue embed to all configured webhooks.
   * @param title The title of the embed.
   * @param description The description of the embed (optional).
   * @throws {ValidationError} If the generated message payload fails Zod validation.
   * @throws {RequestError} If the message fails to send due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors.
   */
  async info(t, n) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    const r = new W().setTitle(t).setColor(G.INFO);
    n && r.setDescription(n);
    const o = new M({ embeds: [r] }), s = [];
    for (const i of this.webhooks) {
      const u = new R(i.axiosInstance);
      try {
        await this._sendOne(o, u);
      } catch (l) {
        s.push({
          webhookUrl: i.url,
          messagePayload: o.getPayload(),
          error: l,
          type: "info"
        });
      }
    }
    if (s.length > 0) {
      const i = s.map(
        (u) => u.error instanceof Error ? u.error.message : String(u.error)
      ).join(`
`);
      throw new v(
        `Failed to send info message to one or more webhooks. Details:
${i}`,
        "INFO_SEND_FAILURE",
        s
      );
    }
  }
  /**
   * Sends a success message with a green embed to all configured webhooks.
   * @param title The title of the embed.
   * @param description The description of the embed (optional).
   * @throws {ValidationError} If the generated message payload fails Zod validation.
   * @throws {RequestError} If the message fails to send due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors.
   */
  async success(t, n) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    const r = new W().setTitle(t).setColor(G.SUCCESS);
    n && r.setDescription(n);
    const o = new M({ embeds: [r] }), s = [];
    for (const i of this.webhooks) {
      const u = new R(i.axiosInstance);
      try {
        await this._sendOne(o, u);
      } catch (l) {
        s.push({
          webhookUrl: i.url,
          messagePayload: o.getPayload(),
          error: l,
          type: "success"
        });
      }
    }
    if (s.length > 0) {
      const i = s.map(
        (u) => u.error instanceof Error ? u.error.message : String(u.error)
      ).join(`
`);
      throw new v(
        `Failed to send success message to one or more webhooks. Details:
${i}`,
        "SUCCESS_SEND_FAILURE",
        s
      );
    }
  }
  /**
   * Sends a warning message with a yellow embed to all configured webhooks.
   * @param title The title of the embed.
   * @param description The description of the embed (optional).
   * @throws {ValidationError} If the generated message payload fails Zod validation.
   * @throws {RequestError} If the message fails to send due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors.
   */
  async warning(t, n) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    const r = new W().setTitle(t).setColor(G.WARNING);
    n && r.setDescription(n);
    const o = new M({ embeds: [r] }), s = [];
    for (const i of this.webhooks) {
      const u = new R(i.axiosInstance);
      try {
        await this._sendOne(o, u);
      } catch (l) {
        s.push({
          webhookUrl: i.url,
          messagePayload: o.getPayload(),
          error: l,
          type: "warning"
        });
      }
    }
    if (s.length > 0) {
      const i = s.map(
        (u) => u.error instanceof Error ? u.error.message : String(u.error)
      ).join(`
`);
      throw new v(
        `Failed to send warning message to one or more webhooks. Details:
${i}`,
        "WARNING_SEND_FAILURE",
        s
      );
    }
  }
  /**
   * Sends an error message with a red embed to all configured webhooks.
   * @param title The title of the embed.
   * @param description The description of the embed (optional).
   * @throws {ValidationError} If the generated message payload fails Zod validation.
   * @throws {RequestError} If the message fails to send due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors.
   */
  async error(t, n) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    const r = new W().setTitle(t).setColor(G.ERROR);
    n && r.setDescription(n);
    const o = new M({ embeds: [r] }), s = [];
    for (const i of this.webhooks) {
      const u = new R(i.axiosInstance);
      try {
        await this._sendOne(o, u);
      } catch (l) {
        s.push({
          webhookUrl: i.url,
          messagePayload: o.getPayload(),
          error: l,
          type: "error"
        });
      }
    }
    if (s.length > 0) {
      const i = s.map(
        (u) => u.error instanceof Error ? u.error.message : String(u.error)
      ).join(`
`);
      throw new v(
        `Failed to send error message to one or more webhooks. Details:
${i}`,
        "ERROR_SEND_FAILURE",
        s
      );
    }
  }
  /**
   * Deletes a previously sent webhook message from all configured webhooks.
   * @param messageLinkOrId The full message link (e.g., from Discord UI) or just the message ID of the message to delete.
   * @throws {RequestError} If the deletion fails due to a network or Discord API error.
   * @throws {WebhookError} For other unexpected errors during deletion.
   */
  async delete(t) {
    if (this.webhooks.length === 0)
      throw new v("No webhook URLs configured.", "NO_WEBHOOK_URLS");
    let n;
    const r = t.match(/\/([0-9]+)$/);
    r ? n = r[1] : n = t;
    const o = `/messages/${n}`, s = [];
    for (const i of this.webhooks) {
      const u = new R(i.axiosInstance);
      try {
        await u.send(
          "DELETE",
          void 0,
          { "Content-Type": "application/json" },
          o
        );
      } catch (l) {
        s.push({
          webhookUrl: i.url,
          error: l,
          type: "delete"
        });
      }
    }
    if (s.length > 0) {
      const i = s.map(
        (u) => u.error instanceof Error ? u.error.message : String(u.error)
      ).join(`
`);
      throw new v(
        `Failed to delete message from one or more webhooks. Details:
${i}`,
        "DELETE_MESSAGE_FAILURE",
        s
      );
    }
  }
}
class zs {
  name;
  value;
  inline;
  /**
   * Creates a new Field instance for an embed.
   * @param name The name of the field (max 256 characters).
   * @param value The value of the field (max 1024 characters).
   * @param inline Optional. Whether the field should be displayed inline with other fields.
   */
  constructor(t, n, r) {
    this.name = t, this.value = n, this.inline = r;
  }
  /**
   * Returns the JSON representation of the field.
   * @returns A plain object representing the field's payload.
   */
  toJSON() {
    return {
      name: this.name,
      value: this.value,
      inline: this.inline
    };
  }
}
function $s(e) {
  return new ws(e);
}
export {
  W as Embed,
  zs as Field,
  me as FileSystemError,
  zt as Footer,
  $t as Image,
  M as Message,
  O as RequestError,
  Zt as Thumbnail,
  Y as ValidationError,
  ws as Webhook,
  v as WebhookError,
  $s as createWebhook
};
